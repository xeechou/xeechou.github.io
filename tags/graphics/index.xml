<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Graphics on Insaturé</title>
    <link>http://localhost:1313/tags/graphics/</link>
    <description>Recent content in Graphics on Insaturé</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 12 Jun 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/graphics/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Modular Vulkan feature and extension manager</title>
      <link>http://localhost:1313/posts/modular-vulkan-feature-manager/</link>
      <pubDate>Wed, 12 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/modular-vulkan-feature-manager/</guid>
      <description>Recently I&amp;#39;ve been trying to squeeze a few hours at a time from my weekends to work on my Vulkan renderer projects. Because the extremely limited time I have, any feature I want need to planned well and get implemented in a few hours or I need to break it down to do so. One of such feature I&amp;#39;ve want to implement is a modular Vulkan Feature management.&#xA;Root Issue: hard-coding enabled features When creating an Vulkan device, you have a lot of options which extensions you want to enable, which feature you want to enable.</description>
    </item>
    <item>
      <title>Comparing Vulkan and D3D12</title>
      <link>http://localhost:1313/posts/vulkan-vs-d3d12/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/vulkan-vs-d3d12/</guid>
      <description>Recently I wrote the PetitD3D12 to extend my graphics API knowledge to the land of DirectX, well I am surprised to see how similar those modern graphics APIs are. More precisely I think Vulkan is trying to stay close to D3D12 these days for be able to easily translate it. However there are also some noticeable differences, surprisingly I did not find too much &amp;ldquo;real&amp;rdquo; API comparison info, the Alain Galvan&amp;rsquo;s blog post are more just about grouping those API data structures together, not much you will know the difference in using them.</description>
    </item>
    <item>
      <title>Moving towards GPU driven</title>
      <link>http://localhost:1313/posts/moving-to-gpu-driven/</link>
      <pubDate>Sat, 13 May 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/moving-to-gpu-driven/</guid>
      <description>We were using a traditional for_each style drawing G-buffer and shadow in Vulkan, with over 2.5 million triangles, and 25,000+ objects, I started to see my GTX 1650 having hard time following it up. Although you can pre-record command buffers in Vulkan to reduce the CPU time but we will also end up with a very large command buffer to submit and potentially miss the driver optimizations with indirect draws. These days, GPUs are getting more and more powerful and complex, including tons of new features.</description>
    </item>
    <item>
      <title>Comparing Vulkan Frameworks</title>
      <link>http://localhost:1313/posts/vulkan-frameworks/</link>
      <pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/vulkan-frameworks/</guid>
      <description>There are indeed many people tried to implement a rendering framework on top of Vulkan to reduce the amount of code to write. But so many of them merely just create a wrapper around existing Vulkan objects, like wrapping the command buffer with a vk::CommandBuffer::Ptr and you still have to fill all the VkObjCreateInfos .&#xA;The rendering framework focus on the render passes should provide a compact yet descriptive API to create render pass.</description>
    </item>
    <item>
      <title>Realistic Deferred MSAA implementation</title>
      <link>http://localhost:1313/posts/deffered_msaa/</link>
      <pubDate>Mon, 03 Dec 2018 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/deffered_msaa/</guid>
      <description>Deferred MSAA, always has been a good problem. In the spatial anti-aliasing domain, MSAA is still the swiss-army knife, handle almost all the case.&#xA;Some other post-processing methods like nvidia&amp;rsquo;s FXAA, AMDs MLAA, or DLAA. FXAA is rather pleasing in many cases as well, especially if you are a video game developer, as long as your rasterization implementation does not screwed up. But for the case like grass rendering, fur rendering, when you have many layers of thin line, FXAA will fail you.</description>
    </item>
    <item>
      <title>Rotations</title>
      <link>http://localhost:1313/posts/rotations/</link>
      <pubDate>Sun, 26 Nov 2017 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/rotations/</guid>
      <description>Rotation, combined with translation and scaling, are the three affin transforms we do every day in the 3D nutshell universe. The rotation itself, however, is somehow much more complicated than the other two transform, it is one really needs a matrix representation among all three. Representations and computation of it has been developed for years. We have systems like Axis-angle representation, matrix representation, euler angles and quaternions. Despite I have known them for a long time, when I forgot, the rotation is still complicated.</description>
    </item>
    <item>
      <title>Bone Animation [part I]</title>
      <link>http://localhost:1313/posts/animation/</link>
      <pubDate>Fri, 10 Nov 2017 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/animation/</guid>
      <description>I have been trying to create a animation system for my OpenGL Project for a long time, one of the reason is I have limited amount of time after starting the full-time job. Another problem was that, I mean, if I intend to keep it a clean project rather than just a school project, building a animation system is like a rabbit hole, 30 lines of code got me another 100 lines of work, it only leaded me deeper and deeper.</description>
    </item>
  </channel>
</rss>
